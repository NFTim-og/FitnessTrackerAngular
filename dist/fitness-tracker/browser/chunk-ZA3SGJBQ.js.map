{
  "version": 3,
  "sources": ["src/app/shared/services/token.service.ts", "src/app/models/user.model.ts", "src/app/services/auth.service.ts"],
  "sourcesContent": ["import { Injectable } from '@angular/core';\n\n/**\n * Token Service\n * Abstracts token storage and retrieval operations\n * Provides a centralized way to manage authentication tokens\n */\n@Injectable({\n  providedIn: 'root'\n})\nexport class TokenService {\n  private readonly TOKEN_KEY = 'fitness_tracker_token';\n  private readonly THEME_KEY = 'darkMode';\n\n  /**\n   * Store authentication token\n   * @param token - JWT authentication token\n   */\n  setToken(token: string): void {\n    try {\n      localStorage.setItem(this.TOKEN_KEY, token);\n    } catch (error) {\n      console.error('TokenService - Error storing token:', error);\n      throw new Error('Failed to store authentication token');\n    }\n  }\n\n  /**\n   * Retrieve authentication token\n   * @returns JWT token or null if not found\n   */\n  getToken(): string | null {\n    try {\n      return localStorage.getItem(this.TOKEN_KEY);\n    } catch (error) {\n      console.error('TokenService - Error retrieving token:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Remove authentication token\n   */\n  removeToken(): void {\n    try {\n      localStorage.removeItem(this.TOKEN_KEY);\n    } catch (error) {\n      console.error('TokenService - Error removing token:', error);\n    }\n  }\n\n  /**\n   * Check if authentication token exists\n   * @returns True if token exists, false otherwise\n   */\n  hasToken(): boolean {\n    return !!this.getToken();\n  }\n\n  /**\n   * Store theme preference\n   * @param isDark - Whether dark mode is enabled\n   */\n  setThemePreference(isDark: boolean): void {\n    try {\n      localStorage.setItem(this.THEME_KEY, String(isDark));\n    } catch (error) {\n      console.error('TokenService - Error storing theme preference:', error);\n      throw new Error('Failed to store theme preference');\n    }\n  }\n\n  /**\n   * Retrieve theme preference\n   * @returns Theme preference or null if not found\n   */\n  getThemePreference(): boolean | null {\n    try {\n      const saved = localStorage.getItem(this.THEME_KEY);\n      return saved ? saved === 'true' : null;\n    } catch (error) {\n      console.error('TokenService - Error retrieving theme preference:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Clear all stored data\n   */\n  clearAll(): void {\n    try {\n      this.removeToken();\n      localStorage.removeItem(this.THEME_KEY);\n    } catch (error) {\n      console.error('TokenService - Error clearing storage:', error);\n    }\n  }\n}\n", "export type UserRole = 'admin' | 'user';\n\nexport class User {\n  id: string;\n  email: string;\n  role: UserRole;\n  created_at: Date;\n  updated_at: Date;\n\n  constructor(data: any = {}) {\n    this.id = data.id || '';\n    this.email = data.email || '';\n    this.role = data.role || 'user';\n    this.created_at = data.created_at ? new Date(data.created_at) : new Date();\n    this.updated_at = data.updated_at ? new Date(data.updated_at) : new Date();\n  }\n}", "/**\n * Authentication Service\n * Handles user authentication, registration, and session management\n */\n\nimport { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { BehaviorSubject, Observable, throwError } from 'rxjs';\nimport { catchError, map, tap } from 'rxjs/operators';\nimport { User } from '../models/user.model';\nimport { environment } from '../../environments/environment';\nimport { ErrorHandlerService } from '../shared/services/error-handler.service';\nimport { TokenService } from '../shared/services/token.service';\n\n/**\n * Authentication Service\n * Injectable service that manages user authentication and session state\n */\n@Injectable({\n  providedIn: 'root' // Service is provided at the root level (singleton)\n})\nexport class AuthService {\n  // API endpoint for authentication\n  private apiUrl = `${environment.apiUrl}/auth`;\n  // BehaviorSubject to store and emit user data\n  private userSubject = new BehaviorSubject<User | null>(null);\n\n  // Observable stream that components can subscribe to\n  user$ = this.userSubject.asObservable();\n\n  /**\n   * Constructor\n   * @param http - Angular HTTP client for making API requests\n   * @param errorHandler - Service for handling and formatting errors\n   * @param tokenService - Service for managing token storage\n   */\n  constructor(\n    private http: HttpClient,\n    private errorHandler: ErrorHandlerService,\n    private tokenService: TokenService\n  ) {\n    this.initializeAuth(); // Initialize authentication state on service creation\n  }\n\n  /**\n   * Initialize authentication state\n   * Checks for existing token and loads user profile if found\n   * @private\n   */\n  private initializeAuth(): void {\n    const token = this.tokenService.getToken();\n    console.log('Auth Service - initializeAuth - Token exists:', !!token);\n    if (token) {\n      console.log('Auth Service - initializeAuth - Getting user profile');\n      // Load user profile using the stored token\n      this.getMe().subscribe({\n        next: (user) => console.log('Auth Service - initializeAuth - User profile loaded:', user),\n        error: (error) => console.error('Auth Service - initializeAuth - Error loading user profile:', error)\n      });\n    }\n  }\n\n  /**\n   * Register a new user\n   *\n   * @param email - User's email address\n   * @param password - User's password\n   * @param passwordConfirm - Password confirmation (for validation)\n   * @returns Observable with token and user data\n   */\n  register(email: string, password: string, passwordConfirm?: string): Observable<{ token: string, user: User }> {\n    return this.http.post<any>(`${this.apiUrl}/register`, { email, password, passwordConfirm })\n      .pipe(\n        map(response => {\n          const { token, data } = response;\n          const user = new User(data.user);\n          this.setSession(token, user); // Store token and update user state\n          return { token, user };\n        }),\n        catchError(error => {\n          return throwError(() => this.errorHandler.handleError(error, 'AuthService.register'));\n        })\n      );\n  }\n\n  /**\n   * Log in an existing user\n   *\n   * @param email - User's email address\n   * @param password - User's password\n   * @returns Observable with token and user data\n   */\n  login(email: string, password: string): Observable<{ token: string, user: User }> {\n    return this.http.post<any>(`${this.apiUrl}/login`, { email, password })\n      .pipe(\n        map(response => {\n          const { token, data } = response;\n          const user = new User(data.user);\n          this.setSession(token, user); // Store token and update user state\n          return { token, user };\n        }),\n        catchError(error => {\n          return throwError(() => this.errorHandler.handleError(error, 'AuthService.login', true));\n        })\n      );\n  }\n\n  /**\n   * Log out the current user\n   * Removes the token and clears the user state\n   */\n  logout(): void {\n    this.tokenService.removeToken(); // Remove token from storage\n    this.userSubject.next(null); // Clear user state\n  }\n\n  /**\n   * Get the current user's profile\n   * Uses the stored token to fetch the user's profile from the API\n   *\n   * @returns Observable with user data\n   */\n  getMe(): Observable<User> {\n    return this.http.get<any>(`${this.apiUrl}/me`)\n      .pipe(\n        map(response => {\n          const user = new User(response.data.user);\n          this.userSubject.next(user); // Update user state\n          return user;\n        }),\n        catchError(error => {\n          this.logout(); // Log out if token is invalid or expired\n          return throwError(() => this.errorHandler.handleError(error, 'AuthService.getMe', false));\n        })\n      );\n  }\n\n  /**\n   * Update the user's password\n   *\n   * @param currentPassword - User's current password\n   * @param newPassword - User's new password\n   * @param newPasswordConfirmation - New password confirmation (for validation)\n   * @returns Observable with new token and updated user data\n   */\n  updatePassword(currentPassword: string, newPassword: string, newPasswordConfirmation?: string): Observable<{ token: string, user: User }> {\n    return this.http.put<any>(`${this.apiUrl}/password`, { currentPassword, newPassword, newPasswordConfirmation })\n      .pipe(\n        map(response => {\n          const { token, data } = response;\n          const user = new User(data.user);\n          this.setSession(token, user); // Update token and user state\n          return { token, user };\n        }),\n        catchError(error => {\n          return throwError(() => this.errorHandler.handleError(error, 'AuthService.updatePassword', true));\n        })\n      );\n  }\n\n  /**\n   * Set the user session\n   * Stores the token and updates the user state\n   *\n   * @param token - JWT authentication token\n   * @param user - User object\n   * @private\n   */\n  private setSession(token: string, user: User): void {\n    console.log('Auth Service - Setting token:', token.substring(0, 10) + '...');\n    this.tokenService.setToken(token); // Store token\n    this.userSubject.next(user); // Update user state\n    console.log('Auth Service - User subject updated:', user);\n  }\n\n  /**\n   * Get the current user\n   * @returns Current user object or null if not logged in\n   */\n  get currentUser(): User | null {\n    return this.userSubject.value;\n  }\n\n  /**\n   * Get the current token\n   * @returns JWT token or null if not logged in\n   */\n  get token(): string | null {\n    return this.tokenService.getToken();\n  }\n\n  /**\n   * Check if user is logged in\n   * @returns True if user is logged in, false otherwise\n   */\n  get isLoggedIn(): boolean {\n    return this.tokenService.hasToken();\n  }\n\n  /**\n   * Check if current user is an admin\n   * @returns True if user is an admin, false otherwise\n   */\n  isAdmin(): boolean {\n    return this.currentUser?.role === 'admin';\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
